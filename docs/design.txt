C++, WinSpd

Disk metadata file: name.chunkdisk
    disk_size
    chunk_size
    num_of_chunks path/to/dir/      # first part
    num_of_chunks path/to/dir/...   # ...

Differential disk: name.chunkdisk
    parent_file                     # maybe differential, for read only
    disk_size                       # same as parent
    chunk_size                      # same as parent
    num_of_chunks path/to/dir/      # first part for this disk
    num_of_chunks path/to/dir/...   # ...

Chunk files:
    part: choose first, second, ... part when creating
    file name: chunk###
    file size: 0 or chunk_size; empty or full
    file never removed after created

Read():
    current -> parent -> ...
    ReadFile()
    chunk not found or empty: zero-fill buffer

Write():
    current only
    WriteFile()
    not found at all: full chunk
    not found in current and found in parent:
        exclusive (locked) access
        copy parent to current

Unmap(): a.k.a. TRIM
    unmap range <  chunk:
        FSCTL_SET_ZERO_DATA, which supports sparse files
        zero-fill if not supported

    unmap range >= chunk:
        exclusive (locked) access
        make it empty by truncating

Asynchronous I/O:
    for best asynchronous performance
        FILE_FLAG_NO_BUFFERING && FILE_FLAG_WRITE_THROUGH

    Alignment requirements with FILE_FLAG_NO_BUFFERING:
        always align to 4096 bytes (pages)
        convert unaligned block I/O to page I/O:
            write through
            flush when aligned
            performance?
                Windows caches virtual disk
                Cluster size is 4096 bytes by default

Close unused file handles to trigger metadata updates

--------------------------------------------------------------------------------

ChunkDiskBase:
    disk parameters
    count num_of_chunks for each part
    remember part id for each chunk file

    .lock file:
        to prevent mistakes
        no double mount for write access: remove .lock when exiting
        deny write access if have been opened as parent: persistent .lock

    CheckChunk(idx)
    CreateChunk(idx, is_write, is_locked) -> FileHandle
    RemoveChunkLocked(idx, handle):
        remove chunk exclusively (locked)
        when failed to copy parent

ChunkDiskService:
    vector<ChunkDiskBase> bases:
        current, parent, ...

    Pages:
        PeekPage(): shared read access
        LockPage(): exclusive write access
        UnlockPage()
        FlushPages(range)
        FlushPages()

    Chunks:
        FindChunk(): find ChunkDiskBase
        CreateChunk(): create/open, read/write, shared/exclusive(locked)
        LockChunk(): mark chunk locked
        CheckChunkLocked(): check if locked
        UnlockChunk(): clear chunk lock

    Unmap Ranges:
        UnmapRange(chunk, range): merge ranges, check if whole
        FlushUnmapRanges(chunk)
        FlushUnmapRanges()

    Last pending disk I/O timestamp
        SetPostFileTime()
        GetPostFileTime()

One worker thread per dispatcher thread

I/O
    Immediate
        bypass I/O or do synchronously
        with file handle not associated with IOCP

    Synchronous
        done synchronously with file handle assocaited with IOCP
        packet sent if successful

    Asynchronous
        done asynchronously (ERROR_IO_PENDING)
        packet sent, check results later

ChunkDiskWorker:
    Pools:
        chunk file handles
            shared among ops
            (read-only, read-write) pair
            LRU policy, <= QD 32

        aligned buffers
            aligned to page, zero-filled
            1048576 + 4096 bytes to shift buffer and align to page
            LIFO policy

    Request/Message â†’ ChunkWork:
        ops: ChunkOpState array
            * chunk operations
            * page operations
            * no mixing of Read(), Write() or Unmap()

        buffer: from pool
            copy DataBuffer for Write()
            Read():
                respond with buffer for asynchronous I/O operations
                copy to DataBuffer for immediate I/O operations
                    DataBuffer not zero-filled

        completed when all ops are completed
        respond with the first error if any

    ChunkOpState:
        Immediate I/O operations: done synchronously in the dispatcher thread
            * read, chunk empty or does not exist
            * read a cached page
            * unmap whole chunk

        Asynchronous I/O operations: may be done synchronously
            * read/write, aligned
            * read/write in a page
            * partial write in a page: read then write
            * partial unmap:
                becomes write operation with buffer nullptr
                partial unmap if and only if write operation with buffer nullptr
                zero-fill using FSCTL_SET_ZERO_DATA (see below)

        Messages: post IOCP packet directly
            * locking chunk file handle

    Event loop using IOCP:
        1. PostWork() in the dispatcher thread
            prepare ChunkWork, ChunkOpState
            do immediate I/O operations
            Post ChunkWork for asynchronous I/O

        2. PostOp()
            do single asynchronous operation
            like ReadFile(), WriteFile(), DeviceIoControl()

        3. CompleteIO()
            check result for the asynchronous operation
            check if ChunkOpState completed

        4. CompleteWork()
            complete ChunkWork if all ChunkOpState are done
            send response to WinSpd

        Idle timer:
            GetQueuedCompletionStatus() timed out
            IdleWork():
                reset pool

                Disk idle?
                    No requests except immediate I/O operations
                    service.SetPostFileTime() in PostWork()
                    service.GetPostFileTime() + idle timer in IdleWork():
                        maybe the last worker
                        service.FlushPages()
                        service.FlushUnmapRanges()
            wait indefinitely

        Check idle file handles:
            Count max. load of pool
            PeriodicCheck():
                check if under low load
                shrink to fit load

    ChunkWork queue:
        Add to list for asynchronous I/O:
            max: QD 32
            wait for list if full

        Remove from list:
            ChunkWork completed
            signal list

        no QD for messages

Synchronize pages:
    flush pages before aligned read/write
    shared lock for page read
    exclusive lock for page miss
    exclusive lock for partial page write: atomic read and write

    Serialize exclusive accesses within the same worker thread:
        SRW locks are not recursive
        check owner thread ID
        singly-linked list for each page:
            PageEntry::user -> ChunkOpState*
            ChunkOpState::next -> ChunkOpState*

            Set PageEntry::user when LockPage() succeeds
            Traverse next and set ChunkOpState::next when LockPage() fails
            Retry when UnlockPage()

Lock chunk file handle:
    mark chunk locked, wait for it if already locked...

    broadcast a message to lock the handles...
        ChunkOpState: add to waiting list if locked...

    wait for the existing references to be closed...
        reply with a message to the sender

    open handle exclusively (locked)
    do an operation...

    broadcast a message to unlock the handles...
        resume ChunkOpState's in the waiting list

Asynchronous Read(), Write():
    Aligned read:
        OpenChunk(read-only)...
        FlushPages(range)...
        ReadFile()...
        CloseChunk()

    Aligned write or zero-fill:
        OpenChunk(read-write)...
            lock chunk, copy parent and retry from beginning if necessary
        FlushPages(range)...
        WriteFile() or DeviceIoControl(FSCTL_SET_ZERO_DATA)...
            DeviceIoControl(FSCTL_SET_ZERO_DATA) not supported?
                set owner ChunkWork buffer from pool
                zero-fill buffer
                repeat WriteFile()...
        CloseChunk()

    Unaligned read:
        OpenChunk(read-only)...
        LockPage()...
        ReadFile()... to page
        CloseChunk()
        copy to buffer
        UnlockPage()

    Unaligned write:
        not whole page?
            Unaligned read...
        OpenChunk(read-write)...
            lock chunk, copy parent and retry from beginning if necessary
        LockPage()/service.ClaimPage()...
        copy/zero-fill page
        WriteFile()... from page
        CloseChunk()
        UnlockPage()

Unmap():
    whole chunk: lock and truncate
    partial: zero-fill

    Merge unmap ranges:
        in a single request:
            sort by address
            merge ranges

        across multiple requests:
            before whole Unmap(): service.FlushUnmapRanges(chunk)
            before Write(): service.FlushUnmapRanges(chunk)
            after FSCTL_SET_ZERO_DATA:
                failure: service.FlushUnmapRanges(chunk)
                success:
                    service.UnmapRange()
                    if whole, while locking range lock:
                        remove read-write handles if idle
                        truncate if all read-write handles are removed

    Unmap() then Read(): EOF
        read successful if zero bytes read and chunk is empty
        remove handle from pool
