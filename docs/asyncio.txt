Problems with naive synchronous implementation
    Sequential access requests get scattered over multiple dispatcher threads
        Access pattern randomized
        Bad sequential performance with HDDs

    Cached twice
        Data in virtual disk, Data in real disk
        Inconsistent virtual disk performance
        Windows may hang if the cache is full

    No queueing

Unbuffered, asynchronous I/O
    Best performance with cache enabled for virtual disk

    No memory used for caching data for real disk
        No need to flush cache

    Requests can be queued
        Queue sequential requests in a worker thread for better performance
        No scattered requests with single dispatcher and multiple worker threads

Performance experiements with DiskSpd
    DRAM: > 1M IOPS, so single dispatcher
    SSD: parallel accesses > outstanding (queued) accesses
    HDD: better sequential performance with queue, tune total request size

Scheduling requests in dispatcher:
    worker = (address / 1048576) % (# of workers)
    choose next worker if QD >= 32, wait if all full

    characteristic
        requests parallelized if depth > 32
        requests serialized if size < 1048576 bytes

Service:
    Chunks
        CreateChunk()
        UnmapChunk()

    Pages
        PeekPage()
        LockPage()
        ClaimPage()
        FreePage()
        FlushPages(range)
        FlushPages(all)

Worker:
    resource pool:
        file handle: may be shared among ops
        aligned buffer: 65536 bytes
        LRU policy, <= QD 32

    std::list<ChunkWork> working
        max. size: 32

        std::vector<ChunkOpState> ops
            operations in range: start off, end off, buffer ptr

            ReadChunk: aligned read (to buffer)
            WriteChunk: aligned write (from buffer)

            ReadPage: acquire, read then release
            WritePage: acquire, write whole page then release
            WritePagePartial: read page then write partially

            UnmapChunk

        # of completed operations
        # of all operations: ops.size()

    event loop using IOCP:
        request:
            create Work
            add it to working

        I/O complete:
            all ops complete?
                copy to DataBuffer
                send response
                done, remove from working

        idle timer:
            IOCP timeout: 1 min.
            reset pool
            wait indefinitely

Read():
    Read chunks...:
        OpenChunk()
        empty or not exist?
            zero-fill buffer
            done for this chunk
        CloseChunk()

        aligned request?
            OpenChunk()
            FlushPages(range)...
            ReadFile()... to buffer
            CloseChunk()

        unaligned request?
            Read pages...:
                PeekPage() succeeded?
                    copy to buffer
                    done for this page

                PeekPage() failed?
                    LockPage()...
                    OpenChunk()
                    ReadFile()... to page
                    CloseChunk()
                    copy to buffer
                    FreePage()

Write():
    Write chunks...:
        aligned request?
            OpenChunk(read-write)
            FlushPages(range)...
            is buffer not null?
                WriteFile()...
            is buffer null?
                DeviceIoControl(FSCTL_SET_ZERO_DATA)...
            CloseChunk()

        unaligned request?
            Write pages...:
                not whole page?
                    Read page...

                LockPage()/ClaimPage()...
                OpenChunk(read-write)
                copy/zero-fill page
                WriteFile()... from page
                CloseChunk()
                FreePage()

Unmap():
    Unmap chunks...:
        partial?
            write chunk...
                set buffer to nullptr to zero-fill

        whole chunk?
            if empty or not exist? done
            truncate chunk to make it empty

Worker:
    1. Prepare
        Create ChunkWork, ChunkOpState
        Try to complete immediately
            * Read empty chunk
            * Read cached page
            * Unmap whole chunk
        Post ChunkWork

    2. Post asynchronous request
        ReadFile(), WriteFile()

    3. Complete operation
        Check result
        Complete ChunkWork if done
            Send response

Page is already in use?
    check whether owner is the current thread
    append State to a singly-linked list
    retry operation after FreePage()

Truncate chunk while it's being used?
    Unmap then Write: incorrect chunk size
    Unmap then Read: EOF

    Cancel I/O

    Refresh chunk state for all workers
        mark as pending

        CloseChunk():
            fix chunk size if opened as read-write
            close handle

        OpenChunk():
            return empty handle if chunk is empty
            fix chunk size
            clear mark
